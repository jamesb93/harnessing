<script>
    import NextSection from "$lib/components/NextSection.svelte"
    import {metadata as m} from "../directory.svx"

</script>


# mosh

[mosh Source Code](https://www.github.com/jamesb93/mosh)

`mosh` is a command-line program for creating audio files by appending valid WAVE headers to raw data. This type of process is referred to as ['databending'](https://en.wikipedia.org/wiki/Databending) and ['datamoshing'](http://datamoshing.com). `mosh` was used to automatically generate a corpus of audio samples for the [Reconstruction Error]({m.re}) project by scraping raw data from my laptop's hard drive.

While composing [Reconstruction Error]({m.re}) I had experimented with converting small batches of files manually from their original format into audio using a modified version of [Alex Harker's ibuffer~ external](https://github.com/AlexHarker/AHarker_Externals/tree/master/ibuffer%20suite). This version was not suitable to be used for the whole project though as it was unstable due to my lack of familiarity with the C programming language. Furthermore, Max is not an environment where iterative processes such loops are easy to express and I preferred to work in a language or environment where such patterns are easily orchestrated. Creating `mosh` solved these issues by being designed specifically for my batch processing use case and by writing it in [Nim](https://nim-lang.org/), a language I am more familiar with.

## Implementation
To convert raw data into an audio file a [WAVE header](http://soundfile.sapp.org/doc/WaveFormat/) is prepended to a series of contiguous bytes. These bytes can be derived from files such as pictures, text files, binaries or static and shared libraries. This makes a new file which the operating system will interpret as an audio file. Thus, `mosh` is responsible for constructing an appropriate header and appending the raw bytes to this. `mosh` is capable of executing this process across any number of files, rather than requiring the user to call `mosh` from elsewhere or wrap it in another script.

`mosh` is called from the command line and accepts arguments to control its behaviour. An example is provided below.

```sh
mosh -i input.file -o output.wav
```

This would create a new audio file named `output.wav` using `input.file` as the raw bytes.

`mosh` has several parameters that dictate the content of the WAVE header that is prepended to the raw bytes. These include number of channels (`numChans`), the sampling rate (`sampRate`) and the bit-depth (`bitDepth`). These have no effect on the process itself other than by controlling how the header is constructed, but by modifying the data inside the header the operating system will interpret the same data different in playback. This provides ways for shaping the databending process which can drastically change the sound of the audio that files that are made. Below, the same data file is processed at two different sample rates and bit depths. I decided not to implement too many parameters to maintain a simple interface that reflected my interests in the databending process and what I found to produce the most noticeable sonic outcomes.

```sh
mosh -i ~/example_input.a -o ~/example_output.wav --bitDepth 8 --numChans 1 --sampRate 44100
mosh -i ~/example_input.a -o ~/example_output.wav --bitDepth 16 --numChans 2 --sampRate 1000
```

`mosh` accepts both single files and entire directories as an input and output. This process is multithreaded, which might seem like over engineering in the context of a tool to support composition but at large quantities of conversion the time required to complete can become long and may hinder the feedback loop of 'moshing' and audition. I believe this makes `mosh` a versatile tool for creative uses as it allows for manipulation through basic parameters and focuses on a single operation, whereas other tools that I experimented with have other purposes and design principles in mind.


<NextSection 
next="ReaCoMa"
link={m.reacoma}
/>